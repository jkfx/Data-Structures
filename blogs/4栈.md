## 栈ADT

### 栈模型

*栈（stack）*是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的*顶（top）*。对栈的基本操作有$Push$（进栈）和$Pop$（出栈），前者相当于插入，后者则是删除最后 插入的元素。最后插入的元素可以通过使用$Top$例程在执行$Pop$之前进行考查。对空栈进行的$Pop$或$Top$一般被认为是栈的ADT的错误。另一方面，当运行$Push$时空间用尽是一个实现错误，但不是ADT错误。

栈有时叫做*LIFO（后进先出）*表。一般的模型是，存在某个元素位于栈顶，而该元素是唯一的可见元素。

### 栈的实现

#### 栈的链表实现

首先，给出一些定义。实现栈要用到一个表头。

```c
#ifndef _Stack_h
#define _Stack_h

typedef int ElementType;
struct Node;
typedef struct Node *PtrToNode;
typedef PtrToNode Stack;

int IsEmpty( Stack S );
Stack CreateStack( void );
void DisposeStack( Stack S );
void MakeEmpty( Stack S );
void Push( ElementType X, Stack S );
ElementType Top( Stack S );
void Pop( Stack S );

#endif  /* _Stack_h */

/* Place in implementation file */
/* Stack implementation is a linked list with a header */
struct Node
{
    ELementType X;
    PrtToNode Next;
};
```

下面给出测试空栈的代码，测试空栈与测试空表的方式相同。

```c
int IsEmpty(Stack S)
{
    return S->Next == NULL;
}
```

创建一个空栈，我们只要建立一个头结点；$MakeEmpty$设置$Next$指针指向$NULL$。

```c
Stack CreateStack(void)
{
    Stack S;
    S = malloc(sizeof(struct Node));
    if(S == NULL)
        FatalError("Out of space!!!");
    S->Stack = NULL;
    MakeEmpty(S);
    return S;
}
void MakeEmpty(Stack S)
{
    if(S == NULL)
        Error("Must use CreateStack first");
    else
        while(!IsEmpty(S))
            Pop(S);
}
```

$Push$是作为向链表前端进行插入而实现的，其中，表的前端作为栈顶。

```c
void Push(ElementType X, Stack S)
{
    PtrToNode TmpCell;
    TmpCell = (PtrToNode)malloc(sizeof(struct Node));
    if(TmpCell == NULL)
        FatalError("Out of space!!!");
    else
    {
        TmpCell->Element = X;
        TmpCell->Next = S->Next;
        S->Next = TmpCell;
    }
}
```

$Top$的实例是通过考查表在第一个位置上的元素而完成的。

```c
ElementType Top(Stack S)
{
    if(!IsEmpty(S))
        return S->Next->Element;
    Error("Empty stack");
    return 0;	/* Return value used to avoid warning */
}
```

最后，$Pop$是通过删除表的前端的元素而实现的。

```c
PtrToNode FirstCell;
if(IsEmpty(S))
    Error("Empty stack");
else
{
    FirstCell = S->Next;
    S->Next = S->Next->Next;
    free(FirstCell);
}
```

很清楚，所有的操作均花费常数时间，因为这些例程没有任何地方涉及到栈的大小（空栈以外）。这种实现方法的缺点在于对malloc和free的调用的开销是昂贵的，特别是与指针操作的例程相比尤其如此。有的缺点通过使用第二个栈可以避免，该第二个栈初始时为空栈。当一个单元从第一个栈弹出时，它只是被放到了第二个栈中。此后，当第一个栈需要新的单元时，它首先去检查第二个栈。

#### 栈的数组实现

另一种实现方法避免了指针并且可能是更流行的解决方案。这种策略潜在危害是我们需要提前声明一个数组的大小。

每一个栈有一个$TopOfStack$，对于空栈它是-1（这就是空栈的初始化）。为了将某个元素$X$压入到该栈中，我们将$TopOfStack$加1，然后置$Stack[TopOfStack]=X$，其中$Stack$是代表具体栈的数组。为了弹出元素，我们置返回值为$Stack[TopOfStack]$然后$TopOfStack$减1。

这些操作不仅以常数时间运行，而且是以非常快的常数时间运行。在某些机器上，若在带有自增和自减寻址功能的寄存器上操作，则（整数的）$Push$和$Pop$都可以写成一条机器指令。栈很可能是在计算机科学中在数组之后最基本的数据结构。

下面给出$Stack$的定义，为指向一个结构体的指针。该结构体包含$TopOfStack$域和$Capacity$域。一旦知道最大容量，则该栈即可被动态地确定。

```c
#ifndef _Stack_h
#define _Stack_h

typedef int ElementType;
struct StackRecord;
typedef struct StackRecord *Stack;

int IsEmpty(Stack S);
int IsFull(Stack S);
Stack CreateStack(int MaxElements);
void DisposeStack(Stack S);
void MakeEmpty(Stack S);
void Push(ElementType X, Stack S);
ElementType Top(Stack S);
void Pop(Stack S);
ElementType TopAndPop(Stack S);

#endif /* _Stack_h */

/* Place in implementation file */
/* Stack implementation is a dynamically allocated array */
#define EmptyTOS (-1)
#define MinStackSize (5)

struct StackRecord
{
    int Capacity;
    int TopOfStack;
    ElementType *Array;
}
```

下面创建一个具有给定的最大值的栈。栈的数组不需要初始化。

```c
Stack CreateStack(int MaxElements)
{
    Stack S;
    if(MaxElements < MinStackSize)
        Error("Stack size is too small");
    S = (Stack)malloc(sizeof(struct StackRecord));
    if(S == NULL)
        FatalError("Out of space!!!");
    S->Array = (ElementType*)malloc(sizeof(ElementType) * MaxElements);
    if(S->Array == NULL)
        FatalError("Out of space!!!");
    S->Capacity = MaxElements;
    MakeEmpty(S);
    return S;
}
```

为了释放栈结构应该编写例程$DisposeStack$。这个例程首先释放栈数组，然后释放栈结构体。

```c
void DisposeStack(Stack S)
{
    if(S != NULL)
    {
        free(S->Array);
        free(S);
    }
}
```

下面是检测一个栈是否空栈的例程。

```c
int IsEmpty(Stack S)
{
    return S->TopOfStack == EmptyTOS;
}
```

下面是创建一个空栈的例程。

```c
void MakeEmpty(Stack S)
{
    S->TopOfStack = EmptyTOS;
}
```

进栈的例程。

```c
void Push(ElementType X, Stack S)
{
    if (IsFull(S))
        Error("Full stack");
    else
        S->Array[++S->TopOfStack] = X;
}
```

将栈顶返回的例程。

```c
ElementType Top(Stack S)
{
    if(!IsEmpty(S))
        return S->Array[S->TopOfStack];
    Error("Empty stack");
    return 0;	/* Return value used to avoid warning */
}
```

从栈弹出元素的例程。

```c
void Pop(Stack S)
{
    if(IsEmpty(S))
        Error("Empty stack");
    else
        S->TopOfStack--;
}
```

$Pop$偶尔写成返回弹出的元素（并使栈改变）的函数。虽然当前的想法是函数不应该改变其输入参数，但是下代码表明这在C中是最方便的方法。

```c
ElementType TopAndPop(Stack S)
{
    if(!IsEmpty(S))
        return S->Array[S->TopOfStack--];
    Error("Empty stack");
    return 0;	/* Return value used to avoid warning */
}
```

